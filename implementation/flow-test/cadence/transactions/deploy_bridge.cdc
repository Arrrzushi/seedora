
      transaction {
        prepare(signer: AuthAccount) {
          signer.contracts.add(
            name: "NounsAuctionBridge",
            code: "import FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport IPRegistration from 0xd0963316d56da678\n\ncontract ProjectAuction {\n    // Events\n    access(all) event AuctionCreated(projectId: UInt64, startPrice: UFix64, endTime: UFix64)\n    access(all) event BidPlaced(projectId: UInt64, bidder: Address, amount: UFix64)\n    access(all) event AuctionSettled(projectId: UInt64, winner: Address, amount: UFix64)\n\n    // Auction struct\n    access(all) struct Auction {\n        access(all) let projectId: UInt64\n        access(all) let startTime: UFix64\n        access(all) let endTime: UFix64\n        access(all) let startPrice: UFix64\n        access(all) let minBidIncrement: UFix64\n        access(all) var currentBid: UFix64\n        access(all) var highestBidder: Address?\n        access(all) var settled: Bool\n\n        init(\n            projectId: UInt64,\n            startPrice: UFix64,\n            duration: UFix64,\n            minBidIncrement: UFix64\n        ) {\n            self.projectId = projectId\n            self.startTime = getCurrentBlock().timestamp\n            self.endTime = self.startTime + duration\n            self.startPrice = startPrice\n            self.minBidIncrement = minBidIncrement\n            self.currentBid = 0.0\n            self.highestBidder = nil\n            self.settled = false\n        }\n    }\n\n    // Contract fields\n    access(all) var auctions: {UInt64: Auction}\n    access(all) let StoragePath: StoragePath\n    access(all) let PublicPath: PublicPath\n\n    // Resource interface for auction management\n    access(all) resource interface AuctionPublic {\n        access(all) fun placeBid(projectId: UInt64, amount: UFix64)\n        access(all) fun getAuction(projectId: UInt64): Auction?\n    }\n\n    // Resource for managing auctions\n    access(all) resource AuctionHouse: AuctionPublic {\n        // Create a new auction\n        access(all) fun createAuction(\n            projectId: UInt64,\n            startPrice: UFix64,\n            duration: UFix64,\n            minBidIncrement: UFix64\n        ) {\n            let auction = Auction(\n                projectId: projectId,\n                startPrice: startPrice,\n                duration: duration,\n                minBidIncrement: minBidIncrement\n            )\n            ProjectAuction.auctions[projectId] = auction\n            emit AuctionCreated(projectId: projectId, startPrice: startPrice, endTime: auction.endTime)\n        }\n\n        // Place a bid on an auction\n        access(all) fun placeBid(projectId: UInt64, amount: UFix64) {\n            pre {\n                ProjectAuction.auctions[projectId] != nil: \"Auction does not exist\"\n                !ProjectAuction.auctions[projectId]!.settled: \"Auction is already settled\"\n                getCurrentBlock().timestamp < ProjectAuction.auctions[projectId]!.endTime: \"Auction has ended\"\n                amount >= ProjectAuction.auctions[projectId]!.startPrice: \"Bid is below start price\"\n                amount >= ProjectAuction.auctions[projectId]!.currentBid + \n                    (ProjectAuction.auctions[projectId]!.currentBid * ProjectAuction.auctions[projectId]!.minBidIncrement): \n                    \"Bid increment too low\"\n            }\n\n            let auction = &ProjectAuction.auctions[projectId] as &Auction\n            auction.currentBid = amount\n            auction.highestBidder = self.owner?.address\n\n            emit BidPlaced(projectId: projectId, bidder: self.owner!.address, amount: amount)\n        }\n\n        // Get auction details\n        access(all) fun getAuction(projectId: UInt64): Auction? {\n            return ProjectAuction.auctions[projectId]\n        }\n\n        // Settle an auction\n        access(all) fun settleAuction(projectId: UInt64) {\n            pre {\n                ProjectAuction.auctions[projectId] != nil: \"Auction does not exist\"\n                !ProjectAuction.auctions[projectId]!.settled: \"Auction is already settled\"\n                getCurrentBlock().timestamp >= ProjectAuction.auctions[projectId]!.endTime: \"Auction has not ended\"\n            }\n\n            let auction = &ProjectAuction.auctions[projectId] as &Auction\n            auction.settled = true\n\n            if let winner = auction.highestBidder {\n                emit AuctionSettled(projectId: projectId, winner: winner, amount: auction.currentBid)\n            }\n        }\n    }\n\n    // Initialize contract\n    init() {\n        self.auctions = {}\n        self.StoragePath = /storage/ProjectAuction\n        self.PublicPath = /public/ProjectAuction\n\n        // Create AuctionHouse resource\n        let auctionHouse <- create AuctionHouse()\n        self.account.save(<-auctionHouse, to: self.StoragePath)\n\n        // Create public capability\n        self.account.link<&{AuctionPublic}>(\n            self.PublicPath,\n            target: self.StoragePath\n        )\n    }\n}"
          )
        }
      }
    